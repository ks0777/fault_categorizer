#!/bin/env python3

from pypcode import Context, PcodePrettyPrinter
from pypcode.pypcode_native import OpCode as OpCode, Instruction, Address
import argparse
from elftools.elf.elffile import ELFFile
from elftools.elf.sections import Section
from elftools.elf.segments import Segment

from loop_integrity import check_li
from ite import check_ite
import util

import pandas

def check_cfi(ops, elf, target_address):
    if any(op.opcode == OpCode.CALL for op in ops):
        return True

    f = util.find_function_by_address(elf, target_address)

    return any(op.opcode == OpCode.RETURN for op in ops)

def categorize_faults(args):
    faults = []

    f_bin = open(args.filename, 'rb')
    elf = ELFFile(f_bin)
    meminfo = pandas.read_hdf(args.hdf, '/Goldenrun/meminfo')

    for target_address in args.address:
        target_address = int(target_address, 16)
        ops = util.extract_pcode_from_elf(elf, target_address, max_instructions=1)

        fault_category = util.FaultCategory.UNKNOWN

        if check_cfi(ops, elf, target_address):
            fault_category = util.FaultCategory.CFI
            continue

        _, start_address, end_address = util.find_function_by_address(elf, target_address)
        function_ops = util.extract_pcode_from_elf(elf, start_address, end_address=end_address)
        basic_blocks = util.find_basic_blocks(function_ops, start_address, end_address)

        postorder = []
        util.build_cfg(basic_blocks, basic_blocks[start_address], [], postorder) 

        idoms = util.find_dominators(basic_blocks, basic_blocks[start_address], postorder)

        #if (cat := check_li(ops, elf, meminfo, target_address)) != None:
        if (cat := check_li(ops, basic_blocks, meminfo, idoms, start_address, target_address)) != None:
            fault_category = cat
        elif (cat := check_ite(basic_blocks, meminfo, idoms, start_address, target_address)) != None:
            fault_category = cat

        faults.append([target_address, fault_category])

    f_bin.close()

    return faults

def main():
    parser = argparse.ArgumentParser(
        prog='Fault Categorizer',
        description='Categorizes discovered faults and suggests fixes'
    )

    parser.add_argument('filename',
        help='Path to the binary to be analyzed')
    parser.add_argument('hdf',
        help='Path to the hdf5 file generated by ARCHIE (meminfo logging needs to be enabled)')
    parser.add_argument('-a', '--address',
        help='Address of skipped instruction that caused an exploitable fault',
        nargs='+',
        required=True
    )

    args = parser.parse_args()

    faults = categorize_faults(args)

    for [address, category] in faults:
        print(f"Fault at {hex(address)} is of type {category}")


if __name__ == '__main__':
    main()
