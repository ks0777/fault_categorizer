#!/bin/env python3

from pypcode import Context, PcodePrettyPrinter
from pypcode.pypcode_native import OpCode as OpCode, Instruction, Address
import argparse
from elftools.elf.elffile import ELFFile
from elftools.elf.sections import Section
from elftools.elf.segments import Segment

from loop_integrity import check_li
from ite import check_ite
import util

import pandas

from call_graph_analysis import CallGraphAnalysis
from data_dependency_analysis import DataDependencyAnalysis
from countermeasures import get_countermeasure

def check_cfi(instructions, elf, target_address):
    ops = instructions[target_address]
    if any(op.opcode == OpCode.CALL for op in ops):
        return True

    f = util.find_function_by_address(elf, target_address)

    return any(op.opcode == OpCode.RETURN for op in ops)

def categorize_faults(args):
    fault_reports = []

    f_bin = open(args.filename, 'rb')
    elf = ELFFile(f_bin)
    meminfo = pandas.read_hdf(args.hdf, '/Goldenrun/meminfo')
    tbexeclist = pandas.read_hdf(args.hdf, '/Goldenrun/tbexeclist')
    tbinfo = pandas.read_hdf(args.hdf, '/Goldenrun/tbinfo')

    instructions = util.load_instructions(elf)
    ddg = DataDependencyAnalysis(instructions, tbexeclist, tbinfo, meminfo)

    for target_address in args.address:
        target_address = int(target_address, 0)

        fault_report = util.FaultReport(target_address, util.FaultCategory.UNKNOWN)

        if check_cfi(instructions, elf, target_address):
            fault_report = util.FaultReport(target_address, util.FaultCategory.CFI)
            fault_reports.append(fault_report)
            continue

        function = util.find_function_by_address(elf, target_address)
        basic_blocks = util.find_basic_blocks(instructions, function.start_address, function.end_address)

        postorder = []
        util.build_cfg(basic_blocks, basic_blocks[function.start_address], [], postorder) 

        idoms = util.find_dominators(basic_blocks, basic_blocks[function.start_address], postorder)

        if (report := check_li(basic_blocks, ddg, idoms, function.start_address, target_address)) != None:
            fault_report = report
        elif (report := check_ite(basic_blocks, instructions, function, ddg, postorder, target_address)) != None:
            fault_report = report

        fault_reports.append(fault_report)

    for report in fault_reports:
        source_line = util.decode_file_line(elf.get_dwarf_info(), report.fault_address)
        print(f"Skipped instruction at {hex(report.fault_address)} ({source_line[0].decode()}:{source_line[1]}) caused fault of type {report.category}")
        if report.affected_branch:
            source_line = util.decode_file_line(elf.get_dwarf_info(), report.affected_branch)
            print(f"\tFault affected branch at {hex(report.affected_branch)} ({source_line[0].decode()}:{source_line[1]})")
        if report.category == util.FaultCategory.UNKNOWN:
            print(f"\tUnable to detect how the skipped instruction influences the control flow. The instruction affects the following instructions: ")
            dependents = ddg.find_dependents(report.fault_address)
            affects_store_op = False
            for dep in dependents:
                print(f"\t\t{str(dep)}")
                for op in instructions[dep.insn_addr]:
                    if op.opcode == OpCode.STORE:
                        affects_store_op = True
                        break

            if affects_store_op:
                print('\tThe skipped instruction affects a store instruction. If the target is inside device memory the analysis can not continue because of insufficient log data.')

        if args.countermeasures:
            get_countermeasure(report)

    #util.debug_console(locals())

    f_bin.close()

    return fault_reports

def main():
    parser = argparse.ArgumentParser(
        prog='Fault Categorizer',
        description='Categorizes discovered faults and suggests fixes'
    )

    parser.add_argument('filename',
        help='Path to the binary to be analyzed')
    parser.add_argument('hdf',
        help='Path to the hdf5 file generated by ARCHIE (meminfo logging needs to be enabled)')
    parser.add_argument('-a', '--address',
        help='Address of skipped instruction that caused an exploitable fault',
        nargs='+',
        required=True
    )
    parser.add_argument('-c', '--countermeasures',
        help='Suggest software-based countermeasures against discovered faults',
        action='store_true'
    )

    args = parser.parse_args()

    faults = categorize_faults(args)


if __name__ == '__main__':
    main()
