#!/bin/env python3

from pypcode import Context, PcodePrettyPrinter
from pypcode.pypcode_native import OpCode as OpCode, Instruction, Address
import argparse
from elftools.elf.elffile import ELFFile
from elftools.elf.sections import Section
from elftools.elf.segments import Segment

from loop_integrity import check_li
from ite import check_ite
import util

import pandas

from call_graph_analysis import CallGraphAnalysis
from data_dependency_analysis import DataDependencyAnalysis

def check_cfi(instructions, elf, target_address):
    ops = instructions[target_address]
    if any(op.opcode == OpCode.CALL for op in ops):
        return True

    f = util.find_function_by_address(elf, target_address)

    return any(op.opcode == OpCode.RETURN for op in ops)

def categorize_faults(args):
    faults = []

    f_bin = open(args.filename, 'rb')
    elf = ELFFile(f_bin)
    meminfo = pandas.read_hdf(args.hdf, '/Goldenrun/meminfo')
    tbexeclist = pandas.read_hdf(args.hdf, '/Goldenrun/tbexeclist')
    tbinfo = pandas.read_hdf(args.hdf, '/Goldenrun/tbinfo')

    instructions = util.load_instructions(elf)
    ddg = DataDependencyAnalysis(instructions, tbexeclist, tbinfo, meminfo)

    for target_address in args.address:
        target_address = int(target_address, 0)

        fault_category = util.FaultCategory.UNKNOWN

        if check_cfi(instructions, elf, target_address):
            fault_category = util.FaultCategory.CFI
            faults.append([target_address, fault_category])
            continue

        function = util.find_function_by_address(elf, target_address)
        function_ops = util.extract_pcode_from_elf(elf, function.start_address, end_address=function.end_address)
        basic_blocks = util.find_basic_blocks(function_ops, function.start_address, function.end_address)

        postorder = []
        util.build_cfg(basic_blocks, basic_blocks[function.start_address], [], postorder) 

        idoms = util.find_dominators(basic_blocks, basic_blocks[function.start_address], postorder)

        if (cat := check_li(basic_blocks, ddg, idoms, function.start_address, target_address)) != None:
            fault_category = cat
        elif (cat := check_ite(instructions, ddg, target_address)) != None:
            fault_category = cat

        faults.append([target_address, fault_category])

    f_bin.close()

    return faults

def main():
    parser = argparse.ArgumentParser(
        prog='Fault Categorizer',
        description='Categorizes discovered faults and suggests fixes'
    )

    parser.add_argument('filename',
        help='Path to the binary to be analyzed')
    parser.add_argument('hdf',
        help='Path to the hdf5 file generated by ARCHIE (meminfo logging needs to be enabled)')
    parser.add_argument('-a', '--address',
        help='Address of skipped instruction that caused an exploitable fault',
        nargs='+',
        required=True
    )

    args = parser.parse_args()

    faults = categorize_faults(args)

    for [address, category] in faults:
        print(f"Fault at {hex(address)} is of type {category}")


if __name__ == '__main__':
    main()
